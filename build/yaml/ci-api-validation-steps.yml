parameters:
  libraries: []

steps:
- task: DownloadPipelineArtifact@1
  displayName: 'Download BotBuilderDLLs artifact'
  inputs:
    artifactName: 'BotBuilderDLLs-Debug-Windows-netcoreapp31'
    targetPath: '$(System.ArtifactsDirectory)/Artifacts'
- ${{ each library in parameters.libraries }}:
    - task: NuGetCommand@2
      displayName: 'NuGet Install Target: ${{ library }}'
      inputs:
        command: custom
        arguments: 'install ${{ library }} -Version $(ApiCompatVersion) -OutputDirectory $(System.DefaultWorkingDirectory)\DownloadedNuGet'

    - task: SOUTHWORKS.binaries-comparer.custom-build-release-task.binaries-comparer@0
      displayName: 'Compare Binaries: ${{ library }}'
      inputs:
        contractsRootFolder: 'DownloadedNuGet\${{ library }}.$(ApiCompatVersion)\lib\netstandard2.0'
        contractsFileName: '${{ library }}.dll'
        implFolder: '$(System.ArtifactsDirectory)/Artifacts'
        failOnIssue: true
        resolveFx: false
        generateLog: true
        outputFilename: '${{ library }}.$(ApiCompatVersion).CompatResults.txt'
        outputFolder: '$(System.DefaultWorkingDirectory)\APICompat'
        useBaseline: false

    - powershell: |
       $FileName = "$(System.DefaultWorkingDirectory)\APICompat\${{ library }}.$(ApiCompatVersion).CompatResults.txt"
       $FileContent = @(Get-Content $FileName)

       $FileContent[0] = $FileContent[0] + " compared against [version $(ApiCompatVersion)](https://www.nuget.org/packages/${{ library }}/$(ApiCompatVersion))"

       if ($FileContent.Length -eq 1) {
       [system.io.file]::WriteAllText($fileName,$FileContent)
       } else {
       Set-Content $fileName $FileContent
       }
       Write-Host "The updated line 1: `n$FileContent[0]"
      displayName: 'Insert nuget link into ApiCompat results file.'

    # - task: PublishBuildArtifacts@1
    #   displayName: 'Publish Compat Results artifact'
    #   inputs:
    #     ArtifactName: '${{ library }}.$(ApiCompatVersion).CompatResults'

# - task: DownloadBuildArtifacts@0
#   displayName: 'Download Compat Results artifact'
#   inputs:
#     downloadType: specific
#     itemPattern: '**\*.txt'
#     downloadPath: '$(System.ArtifactsDirectory)\ApiCompat'
#   condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))

- task: Southworks-Pipelines-Test.github-pr-comment-test.custom-publish-comment-task.github-pr-comment-test@0
  displayName: 'Publish Compat Results to Github'
  inputs:
    userToken: '$(GitHubCommentApiKey)'
    bodyFilePath: '$(System.DefaultWorkingDirectory)\ApiCompat'
    getSubFolders: true
  condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))

- powershell: |
   # Check for string in the logs in the current DevOps pipeline run.
   # 
   # Note: The task immediately before this one may not get checked because its log may not yet be available.
   # Calls the Azure DevOps REST API.
   # Enable OAuth token access in the pipeline agent job for $(System.Accesstoken) to populate.

   $stringToCheckFor = '201 Created';
   
   Start-Sleep -Milliseconds 1000 # Give time for the last log to become available
   
   $collectionUri = "$env:SYSTEM_COLLECTIONURI";  # e.g. 'https://fuselabs.visualstudio.com'
   $teamProjectId = "$env:SYSTEM_TEAMPROJECTID";  # e.g. '86659c66-c9df-418a-a371-7de7aed35064' = SDK_v4
   
   # Get the current build ID.
   $buildId = "$env:BUILD_BUILDID";
   Write-Host 'Build ID = ' $buildId;
   
   # Get the log containers for the run.
   $uri = "$collectionUri/$teamProjectId/_apis/build/builds/$buildId/logs";
   
   $token = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(":$(System.AccessToken)"));
   $header = @{authorization = "Basic $token"};
   
   $runLogContainers = Invoke-RestMethod "$uri" -Method Get -ContentType "application/json" -Headers $header;
   
   # Get the log from each log container.
   Write-Host 'Checking the logs:';
   $found = $false;
   foreach ($container in $runLogContainers.value) {
       $container.id;
       $uri = $container.url;
       $uri;
       $log = Invoke-RestMethod "$uri" -Method Get -ContentType "application/json" -Headers $header;
       
       # Search for our string.
       if (!$found -and $log.Contains($stringToCheckFor)) {
           $found = $true;
           $log;
           $mess = 'String "' + $stringToCheckFor + '" found in log #' + $container.id;
           Write-Host $mess;
       } else {
           ($log -split '\r?\n')[0] + '...';  # Print first line
       }
   }
   
   # If not found, throw an error.
   if (!$found) {
       Write-Host;
       $mess =  'Publish Compat Results failed. Is there a PR associated with this build? String "' + $stringToCheckFor + '" not found in the logs';
       throw $mess;
   }
   
  displayName: 'Verify Publish Compat Results success'
  continueOnError: true
  condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))

- script: |
   cd ..
   dir /s
  displayName: 'Dir workspace'
  continueOnError: true
  condition: succeededOrFailed()
